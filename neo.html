<html>

<head>
<title>Neo</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body>

<h1 align="center">Neo</h1>

<h2 align="left">Introduction</h2>

<p><strong>Neo</strong> is a webserver currently being written at <a
href="http://www.franz.com">Franz Inc</a>.&nbsp;&nbsp; <em>The name <strong>neo</strong>
is just an internal project name and isn't intended to be the name of&nbsp; the final
product.</em>&nbsp;&nbsp;&nbsp; Neo is designed to work with the <a href="htmlgen.html">htmlgen</a>
system for generating dynamic html, as one of the big advantages of&nbsp; a web server
written in Common Lisp is the ability to generate html dynamically.&nbsp; In this document
we'll consider the web server and dynamic html generation to be parts of the same product.</p>

<p>The design goals of Neo are: 

<ul>
  <li>a very small footprint.&nbsp;&nbsp; It should be possible to make Neo a part of every
    application without being concerned about the impact of its size and processing
    requirements.</li>
  <li>simple configuration.&nbsp; Neo should start automatically with minimal input from the
    user.&nbsp; </li>
  <li>easy to use.&nbsp;&nbsp; The typical scenarios should be easy to program with just
    knowledge of simple html.</li>
  <li>usable in commerical applications .</li>
  <li>support the latest http protocol (currently HTTP/1.1)</li>
  <li>runnable in multiple configuration.&nbsp;&nbsp;&nbsp; We want to support a program that
    just wants to make some part of it visible or configurable by one user through a web
    server.&nbsp; We also want to support&nbsp; a web site running on a multiprocessor taking
    many hits per second.&nbsp;&nbsp; And we want so support levels inbetween those scenarios.</li>
</ul>

<p>&nbsp;</p>

<h2>Running Neo</h2>

<p>Running&nbsp; Neo requires that you 

<ul>
  <li><strong>load</strong> <em>neo.fasl</em> into Lisp</li>
  <li><strong>publish </strong>zero or more urls</li>
  <li><strong>start</strong> the server</li>
  <li><strong>publish </strong>zero or more urls</li>
</ul>

<p>We mention <strong>publish</strong> twice to emphasize that you can publish urls before
and after you start the server.</p>

<p>&nbsp;</p>

<h2>Starting the server</h2>

<p>The function <font face="Courier New">neo:start</font> is used to start the server
running.</p>

<p><strong><font face="Courier New">(start &amp;key port listeners chunking keep-alive
server debug)</font></strong></p>

<p>If no arguments are given then <strong>start</strong>&nbsp; starts a multi-threaded web
server on port 80, which is the standard web server port.&nbsp;&nbsp;&nbsp; If you are
running this on Unix then you can only allocate port 80 if you are logged in as root or
have made Lisp a set-user-id root program.</p>

<p>The&nbsp; are quite a few keyword arguments to <strong>start</strong>, but in practice
you only need be concerned with <strong>:port</strong> and <strong>:listeners.
&nbsp;&nbsp;&nbsp; </strong>The arguments have the following meanings: 

<ul>
  <li>port -- the port on which to open the web server.&nbsp; 80 is the default.</li>
  <li>listeners -- the number of threads to process http requests.&nbsp;&nbsp;&nbsp;&nbsp; If
    a value isn't given for the <strong>:listeners</strong> argument then 5 is assumed. &nbsp;
    If&nbsp; the value is <strong>nil </strong>or <strong>0 </strong>then the server runs in <em>simple
    server mode<strong> </strong></em>in which the <strong>start</strong> function doesn't
    return - instead it processes the requests itself, one at a time.&nbsp; If a positive
    number is given as the value of <strong>:listeners</strong> then the server runs in <em>threaded
    server mode<strong>.</em> </strong>&nbsp; In this mode separate lisp lightweight processes
    are started to handle requests from clients, the number of request handing threads equal
    to the value of the <strong>:listeners</strong> keyword argument.&nbsp; In this mode the <strong>start
    </strong>function returns after starting the other threads.</li>
  <li>chunking -- if true then the server will using the chunked transfer encoding when it's
    possible to do so.&nbsp; This is an optimization and should be left enabled unless you
    suspect that it is the cause of some sort of error.&nbsp;&nbsp; The default is true.</li>
  <li>keep-alive -- if true then the server will keep connections alive if requested by the
    web client, and if there are sufficient free threads to handle new requests coming in.
    &nbsp;&nbsp; This is an optimization and should be left on.&nbsp;&nbsp; The default is
    true.</li>
  <li>server -- if this is a passed a value it must be a <strong>wserver</strong> object,
    which denotes&nbsp; a particular instance of a web server.&nbsp;&nbsp; This is for support
    of running multiple independent web servers in the same lisp image.&nbsp; This will be
    described in a later section (eventually).</li>
  <li>debug -- if given a number this will print debugging messages whose associated codes are
    this number or less.&nbsp;&nbsp;&nbsp; This is really an internal switch and may be
    removed in future versions.</li>
</ul>

<p>&nbsp;</p>

<h2>Shutting down the server</h2>

<p><strong><font face="Courier New">(shutdown &amp;optional server)</font></strong></p>

<p>This shuts down the web server given (or the most recently started web server if no
argument is passed in).</p>

<p>&nbsp;</p>

<h2>Publishing information</h2>

<p>Once the server is started it will accept requests from http clients, typically web
browsers.&nbsp;&nbsp; Each request is parsed and then Neo searches for an object to handle
that request.&nbsp;&nbsp; That object is called an <strong>entity</strong>.&nbsp; If an
entity is found, it is passed the request and is responsible for generating and sending a
response to the client.&nbsp; If an entity can't be found then Neo sends back a response
saying that that request was invalid.</p>

<p><em>Publishing</em> is the process of creating entities and registering them in the
tables scanned by Neo after a request is read.</p>

<h3>Components of a request</h3>

<p>A request from an http client contains a lot of information.&nbsp; The three items that
determine which entity will handle the request are 

<ul>
  <li>the name part of the url minus any arguments.&nbsp;&nbsp; The arguments are the
    characters beginning with the first '?' and extending to the end of the url.&nbsp; For
    example in the url&nbsp; <a href="http://bar.com:8030/files/foo?xx=3&amp;yy=4">http://bar.com:8030/files/foo?xx=3&amp;yy=4</a>
    the part we call the name is just <strong>/files/foo.</strong></li>
  <li>the host to which the request is directed.&nbsp;&nbsp; This is not necessarily the host
    that is receiving the request due to virtual hosts and proxy servers.&nbsp; This value
    comes from the <strong>Host:</strong> header line, if one is given.&nbsp; If the <strong>Host:</strong>
    header line isn't given then this value is <em>unspecified</em> for this request.</li>
  <li>the port to which the request was directed.&nbsp; Again, this information comes from <strong>Host:</strong>
    header line, if it is present in the request.&nbsp; If it is not present then this value
    is <em>unspecified</em>.<font color="#FF0000"> [[this seems wrong.... it should probably
    default to the actual port number on which neo is listening]]</font></li>
</ul>

<p>&nbsp;</p>

<p>A request contains other information and while that information isn't used to determine
which entity will handle the request it can be used by the entity handling the request in
any way it sees fit.</p>

<p>&nbsp;</p>

<p>The following functions create entities and specify which requests they will handle:</p>

<p>&nbsp;</p>

<p><strong><font face="Courier New">(publish-file &amp;key path host port&nbsp; file
content-type class preload server)</font></strong></p>

<p>This creates an entity that will return the contents of a file on the disk in response
to a request.&nbsp;&nbsp; The <strong>url</strong>, <strong>file</strong> and <strong>content-type</strong>
must be given, the rest of the arguments are optional. (We plan to make <strong>content-type</strong>
optional too in the future).&nbsp; The arguments have these meanings: 

<ul>
  <li><strong>path </strong>-- a string that must match the name part of the url as described
    above in <strong>Components of a Request</strong></li>
  <li><strong>host -- </strong>a string that must match (in a case insensitive manner) the
    host part of the request.&nbsp;&nbsp; If this argument is not given then it will match the
    host part of any request.&nbsp; If this argument is given and the request does not have a
    host part specified, then it will not match.</li>
  <li><strong>port</strong> -- a number that must match the port part of the request.&nbsp; If
    this argument is not given then it will match the port&nbsp; part of any request.&nbsp; If
    this argument is given and the request does not have a port&nbsp; part specified, then it
    will not match.</li>
  <li><strong>file </strong>-- the name of the file to return when a request this entity is
    made.&nbsp;&nbsp; The file doesn't have to exist until the request is made unless <strong>preload</strong>
    is specified as true.</li>
  <li><strong>content-type</strong> -- A string describing the content of the file.&nbsp; This
    often referred to as the MIME type of the file.&nbsp; An example is &quot;text/html&quot;
    to describe an html file.</li>
  <li><strong>class</strong> -- a Clos class name or class object to be used to hold this
    entity.&nbsp; The class must be a subclass of&nbsp; <strong>file-entity</strong>.
    &nbsp;&nbsp; </li>
  <li><strong>preload</strong> --if true it instructs <strong>neo</strong> to read the
    contents of the file in immediately and store it in a lisp object.&nbsp; This will speed
    up the reponse to this request.</li>
  <li><strong>server</strong> -- if this entity should only be served by a particular server,
    then this specifies which server.&nbsp;&nbsp; See the section (to be written) on running
    multiple servers in the same Lisp process.</li>
</ul>

<p>The function that handles requests for files will respond correctly to <strong>If-Modified-Since</strong>
header lines and thus minimize network traffic. </p>

<p>Example: </p>

<p>This will work on Unix where the password file is stored in /etc.</p>

<pre>(publish-file :path &quot;/password&quot; :file &quot;/etc/passwd&quot; :content-type &quot;text/plain&quot;)</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong><font face="Courier New">(publish-directory &amp;key prefix host port
destination server)</font></strong></p>

<p>This creates a mapping from all urls whose name begins with<strong> prefix</strong> to
files stored in the directory specified by the destination.&nbsp;&nbsp; The <strong>host</strong>,
<strong>port </strong>and <strong>server</strong> arguments are as described above for <strong>publish.</strong>
&nbsp;&nbsp;&nbsp;&nbsp; When a request comes in for which there isn't an entity that
matches it exactly,&nbsp; Neo checks to see if a prefix of the request matches the
request.&nbsp; If so, and if the resulting entity is a <strong>directory-entity</strong>
as created by this function, then it strips the prefix off the given request and appends
the remaining part of the request to the destination string.&nbsp; It then publishes that
(using <strong>publish-file</strong> and computing the content-type from the file type).
&nbsp;&nbsp; Next that <strong>file-entity </strong>is made to handle the request in the
normal manner.</p>

<p>We plan to make a number of refinements to <strong>publish-directory</strong> including
the ability to specify how deep in the directory structure it will look and also
&nbsp;&nbsp; restricting what kinds of files it will match.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong><font face="Courier New">(publish &amp;key path host port content-type function
class format server)</font></strong></p>

<p>This creates a mapping from a url to a <strong>computed-entity</strong>, that is an
entity that computes its response every time a request comes in.&nbsp; The <strong>path</strong>,
<strong>host</strong>, <strong>port</strong>, <strong>server</strong> and <strong>class</strong>
arguments are as in the other publish functions.&nbsp;&nbsp; The <strong>content-type</strong>
sets a default value for the response to the request but this can be overridden.&nbsp; The
<strong>format</strong> argument is either <strong>:text </strong>(the default) or <strong>:binary</strong>
and it specifies the kind of value that will be sent back (after the response headers,
which are always in text).&nbsp;&nbsp; This value is only important if the response is
generated in a particular way (described below).</p>

<p>The <strong>function </strong>argument is&nbsp; a function of two arguments: an object
of class <strong>http-request</strong> that holds a description of the request, and an
object of class <strong>entity </strong>that holds this entity which is handling the
request.&nbsp;&nbsp; This function must generate a response to the http request, even if
the response is only that the request wasn't found.</p>

<p>&nbsp;</p>

<h2>Generating a computed response </h2>

<p>There are a variety of ways that a response can been sent back to the http client
depending on whether keep-alive is being done, chunking is possible, whether the response
is text or binary, whether the client already has the most recent data, and whether the
size of the body of the response is known before the headers are sent.&nbsp; Neo deals
with complexity of determing the optimal response strategy and the user need only use a
few specific macros in the computation of the response in order ot take advantage of Neo's
strategy computation</p>

<p>Here's a very simple computed response.&nbsp; It just puts &quot;Hello World!&quot; in
the browser window:</p>

<pre>(publish :path &quot;/hello&quot;
         :content-type &quot;text/html&quot;
         :function #'(lambda (req ent)
                       (with-http-response (req ent)
                          (with-http-body (req ent)
                             (html &quot;Hello World!&quot;)))))

</pre>

<p align="left">This example works regardless of whether the request comes in from an old
HTTP/0.9 browser or a modern HTTP/1.1 browser.&nbsp; It may or may not send the response
back with Chunked transfer encoding and it may or may not keep the connection alive after
sending back the response.&nbsp;&nbsp; The user code doesn't have to deal with those
possibilities, it just uses <strong>with-http-response</strong> and <strong>with-http-body</strong>
and the rest is automatic.&nbsp; The <strong>html</strong> macro is part of the htmlgen
package that accompanies Neo.&nbsp;&nbsp; In the case above we are being lazy and not
putting out the html directives that should be found on every page of html since most
browsers are accomodating.&nbsp;&nbsp; Here's the function that generates the correct
html:</p>
<div align="left">

<pre>(publish :path &quot;/hello2&quot;
         :content-type &quot;text/html&quot;
         :function #'(lambda (req ent)
                       (with-http-response (req ent)
                         (with-http-body (req ent)
                           (html 
                             (:html
                               (:body &quot;Hello World!&quot;)))))))</pre>
</div>

<p align="left">&nbsp;</p>

<p align="left">The function above generates: <font face="Courier New">&lt;html&gt;&lt;body&gt;Hello
World!&lt;/body&gt;&lt;/html&gt;.</font></p>

<p align="left">&nbsp;</p>

<p align="left">The macros and functions used in computing responses are these:</p>

<hr>

<p align="left"><strong><font face="Courier New">(with-http-response (req ent &amp;key
timeout check-modified response content-type) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;rest body)</font></strong></p>

<p align="left">This macro begins the process of generating a responds to an http request
and then it runs the code in the <strong>body</strong> which will actually send out the
response.&nbsp; <strong>req</strong> and <strong>ent</strong> are the request and entity
objects passed into the function designated to compute the response for the request.
&nbsp;&nbsp;&nbsp; <strong>timeout </strong>sets a time limit for the computation of the
response.&nbsp;&nbsp; The default is 60 (meaning 60 seconds).&nbsp;&nbsp; If <strong>check-modified
</strong>is true (the default) then the <strong>last-modified </strong>time stored in the
entity object will be compared against the <strong>if-modified-since </strong>time of the
request and if that indicates that the client already has the latest copy of this entity
then a <strong>not-modified</strong> response will be automatically returned to the client
and the <strong>body </strong>of this macro will not be run.&nbsp;&nbsp; <strong>response </strong>is
an object contaning the code and description of the http response we wish to return.
&nbsp;&nbsp; The default value is the value of <strong>*response-ok*</strong> (which has a
code of 200 and a string descriptor &quot;OK&quot;).&nbsp;&nbsp; <strong>content-type </strong>is
a string describing the MIME type of the body (if any) sent after the headers.&nbsp; It
has a form like &quot;text/html&quot;.&nbsp;&nbsp; If <strong>content-type</strong> isn't
given here then the content-type value in the entity (which is set in the call to <strong>publish)</strong>
will be used.</p>

<p align="left">&nbsp;</p>

<p align="left">An http response consists of a line describing the response code, followed
by headers (unless it's the HTTP/0.9 protocol in which case there are no headers),
&nbsp;&nbsp; and then followed by the body (if any) of the response.&nbsp;&nbsp; <strong>with-http-response</strong>
doesn't normally send anything to the client.&nbsp; It only does so when it determines
that the <strong>if-modified-since</strong> predicate doesn't hold and that it must send
back a <strong>not-modified</strong> response.&nbsp;&nbsp;&nbsp; Thus in the normal case
it isn't enough, even if there no body to send, to just call <strong>with-http-response</strong>.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is where the <strong>with-http-body </strong>is used.</p>

<p align="left">&nbsp;</p>

<hr>

<p align="left"><strong><font face="Courier New">(with-http-body (req ent &amp;key format
headers)&nbsp; &amp;rest body)</font></strong></p>

<p align="left">This macro causes the whole http response to be sent out.&nbsp; The macro
itself will send out everything except the body of the response.&nbsp; That is the
responsibility of the code supplied as the <strong>body </strong>form of the macro.
&nbsp;&nbsp;&nbsp; In cases where there is no body to the response being sent it is still
necessary to call <strong>with-http-body </strong>so that the other parts of the response
are sent out, e.g.<font face="Courier New"> </font>at a minimum you should put<font
face="Courier New"> (with-http-body (req ent)) </font>in the body of an with-http-response</p>

<p align="left">The <strong>format</strong> argument specifies whether the code in the <strong>body</strong>
will want to write <strong>:text</strong> (e.g. <strong>write-char</strong>) or <strong>:binary</strong>
(e.g. <strong>write-byte</strong>) when it writes the data of the body of the response.
&nbsp;&nbsp;&nbsp;&nbsp; Based on the value of the <strong>format</strong> argument, Neo
will create the correct kind of response stream.&nbsp;&nbsp; If <strong>format </strong>is
not specified here it will default to the value specified when <strong>publish</strong>
was called to create the entity.</p>

<p align="left">The <strong>headers</strong> argument is a list of conses, where the car
is the header name (a string) and the cdr is the header value.&nbsp; These headers are
added to the headers sent as part of this response.</p>

<p align="left">Within the <strong>body </strong>forms the code calls <strong>(resp-stream
req)</strong> to obtain a stream to which it can write to supply the body of the response.</p>

<hr>

<p><strong><font face="Courier New">(get-request-body request)</font></strong></p>

<p>Return the body of the request as a string.&nbsp; If there is no body the return value
will be an empty string or nil.&nbsp;&nbsp; If a request has a body you should call this
function even if you don't plan on using what is in the body.&nbsp; <em>We will fix this
in future version so that you don't always have to call this function if you don't need
the value.&nbsp; </em>The typical reason for their to be a body to a request is when a web
browser sends the result of a form with&nbsp; a POST method.</p>

<hr>

<p><strong><font face="Courier New">(header-slot-value request header-name)</font></strong></p>

<p>Return the value given in the request for the given header-name (a string).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The header-name string should be all lower case.&nbsp; If
the header wasn't present in this request then nil will be returned.&nbsp;&nbsp; <strong>header-slot-value</strong>
is a macro that will expand into a fast accessor if the <strong>header-name</strong> is a
constant string.</p>

<hr>

<p><strong><font face="Courier New">(url-argument-alist request)</font></strong></p>

<p>Decode and return an alist of the arguments to this url.&nbsp;&nbsp; The arguments
begin at the first question mark and continue until the end of the url.&nbsp;&nbsp; Each
item in the alist is a cons where the car is a string giving the name of the argument and
the cdr is a string giving the value of the argument.</p>

<hr>

<p>&nbsp;</p>

<h2>request object reader and accessors</h2>

<p>The request object contains information about the http request being processed and it
contains information about the response that is being computed and returned to the
requestor.&nbsp;&nbsp; The following functions access slots of the request object. &nbsp;
Those with names beginning with <strong>resp-</strong> are accessing the slots which hold
information about the response the to request.&nbsp;&nbsp; When a function is listed as an<em>
accessor<strong> </strong></em>that means that it can be <strong>setf</strong>'ed as well
as used to read the slot value.</p>

<p><strong><font face="Courier New">(resp-code request)</font></strong>
&nbsp;&nbsp;&nbsp;&nbsp; - accessor - the value is describes the response code and string
we will return for this request.&nbsp;&nbsp; See the value of the argument <strong>response</strong>
in <strong>with-http-response</strong> for more information.</p>

<p><strong><font face="Courier New">(resp-date request)</font></strong>
&nbsp;&nbsp;&nbsp;&nbsp; - accessor - the date the response will be made (in Lisp's
universal time format)</p>

<p><strong><font face="Courier New">(resp-content-length request) </font></strong>&nbsp;&nbsp;&nbsp;
- accessor -&nbsp; the value to send as the Content-Length of this response.&nbsp;&nbsp;
This is computed automatically by neo and thus a user program shouldn't have to set this
slot under normal circumstances.</p>

<p><strong><font face="Courier New">(resp-plist request)</font></strong>
&nbsp;&nbsp;&nbsp;&nbsp; - accessor -&nbsp; this slot holds a property list on which neo
uses to stores some lesser used information.&nbsp; The user program can use it as well.</p>

<p><font face="Courier New"><strong>(resp-strategy request)</strong></font>&nbsp;&nbsp; -
accessor - the strategy is a list of symbols which describe how neo will build a response
stream and will send back a response.&nbsp; More details will be given about the possible
strategies at a future time.</p>

<p><strong><font face="Courier New">(resp-stream request)</font></strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - accessor -&nbsp; This is the stream to be used in user
code to send back the body of the response. </p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<hr>

<h2>Form Processing</h2>

<p>Forms are used on web pages in order to allow the user to send information to the web
server.&nbsp;&nbsp; A form consists of a number of objects, such as text fields, file
fields, check boxes and radio buttons.&nbsp;&nbsp; Each field has a name.&nbsp;&nbsp; When
the user takes a certain action, the form data is encoded and sent to the web server.
&nbsp;&nbsp;&nbsp; There are three ways that data can be sent to the web server.&nbsp; The
method used is determined by the attributes of the <strong>&lt;form&gt;</strong> tag that
defines the form 

<ul>
  <li><strong>&lt;form method=&quot;get&quot;&gt; -&nbsp; </strong>The data is made part of
    the <strong>url</strong> that is sent to the web server and is separated from the url
    itself by a question mark.&nbsp; The neo url handler code uses <strong>(url-argument-alist</strong>
    <strong>req)</strong> to retrieve the alist of form names and values.&nbsp;&nbsp; This
    method has a few disadvantages - the amount of data that can be sent is limited since the
    size of urls is limited.&nbsp; Also the data is visible to everyone seeing the url and
    that may not be desireable.&nbsp; </li>
  <li><strong>&lt;form method=&quot;post&quot;&gt; - </strong>The data is send in the body of
    the request.&nbsp;&nbsp;&nbsp; The neo url handler code calls <strong>(get-request-body
    req)</strong> to retrieve the body from the web browser and then <strong>(decode-form-urlencoded
    body) </strong>to turn it into an alist that associates form field names with values.</li>
  <li><strong>&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; - </strong>The
    data is sent in the body of the request in MIME format, with each field in its own
    separate MIME entity.&nbsp;&nbsp;&nbsp; This method is only necessary when one of the
    fields in the form is a <strong>&lt;input type=&quot;file&quot;&gt;</strong> ssince that
    causes the whole contents of a file to be sent from the browser to the web server. &nbsp;
    When sending a file you would like to include information such as the file name and
    content-type of the file, and by sending it in MIME format there is room for this
    information in the MIME header.&nbsp;&nbsp; We describe how to retrieve data from such a
    form next.</li>
</ul>

<h3>Retreving multipart/form-data information</h3>

<p>If you create a form with <strong>&lt;form method=&quot;post&quot;
enctype=&quot;multipart/form-data&quot;&gt;</strong> then your url handler must do the
following to retrieve the value of each field in the form: 

<ol>
  <li>Call <strong>(get-multipart-header req)</strong> to return the MIME headers of the next
    field.&nbsp; If this returns nil then there are no more fields to retrieve.</li>
  <li>Create a buffer and call <strong>(get-multipart-sequence req buffer)</strong> repeatedly
    to return the next chunk of data.&nbsp; When there is no more data to read for this field
    &nbsp; <strong>get-multipart-sequence</strong> will return nil.&nbsp; </li>
  <li>go back to step 1</li>
</ol>

<p>It's important to retrieve all of the data sent with the form, even if that data is
just ignored.&nbsp; This is because there may be another http request following this one
and it's important to advance to the beginning of that request so that it is properly
recognized.&nbsp;&nbsp; </p>

<p>Details on the functions are given next.</p>

<p>&nbsp;</p>

<hr>

<p><strong><font face="Courier New">(get-multipart-header request)</font></strong></p>

<p>This returns nil or&nbsp; the MIME headers for the next form field in alist form.
&nbsp;&nbsp;&nbsp; If nil is returned then there is no more form data.&nbsp;&nbsp; </p>

<p>For an input field such as <strong>&lt;input type=&quot;text&quot;
name=&quot;textthing&quot;&gt; </strong>the value returned by <strong>get-multipart-header</strong>
would be</p>

<pre>((&quot;Content-Disposition&quot;
      (:param &quot;form-data&quot; (&quot;name&quot; . &quot;textthing&quot;))))</pre>

<p>For an input field such as <strong>&lt;input type=&quot;file&quot;
name=&quot;thefile&quot;&gt; </strong>the value returned by <strong>get-multipart-header</strong>
would be something like</p>

<pre>((&quot;Content-Disposition&quot;
      (:param &quot;form-data&quot; (&quot;name&quot; . &quot;thefile&quot;)
                          (&quot;filename&quot; . &quot;C://down//550mhz.gif&quot;)))
 (&quot;Content-Type&quot; &quot;image/gif&quot;))</pre>

<p>Note that the filename is expressed in the syntax of the operating system on which the
web browser is running.&nbsp; This syntax may or may not make sense to the Lisp pathname
functions of the Neo web server as it may be running on a totally different operating
system.</p>

<p>&nbsp;</p>

<hr>

<p><strong><font face="Courier New">(get-multipart-sequence request buffer &amp;key start
end raw)</font></strong></p>

<p>This retrieves the next chunk of data for the current form field and stores it in <strong>buffer</strong>.
&nbsp;&nbsp; If <strong>start</strong> is given then it specifies the index in the buffer
at which to begin storing the data.&nbsp; If <strong>end</strong> is given then it
specifies the index just after the last index in which to store data.</p>

<p>The return value is <strong>nil </strong>if there is no more data to return, otherwise
it is the index one after the last last index filled with data in <strong>buffer.</strong></p>

<p>The buffer can be a one dimensional array of <strong>character</strong> or of <strong>(unsigned-byte
8)</strong>.&nbsp;&nbsp; If the buffer is a <strong>character</strong> buffer then <strong>raw</strong>
defaults to <strong>nil, </strong>otherwise <strong>raw </strong>defaults to true.</p>

<p>If <strong>raw </strong>is true then the buffer is filled with the bytes just as they
are sent from the web browser.&nbsp; If <strong>raw</strong> is false then the sequence of
characters #\return #\newline is converted to just #\newline (which is the preferred
format for line separation in Lisp strings).</p>

<p><strong>get-multipart-sequence</strong> may return before filling up the whole buffer,
so program should be sure to make use of the index returned by <strong>get-multipart-sequence</strong>.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<hr>

<hr>

<h2>Cookies</h2>

<p>Cookies are name value pairs that a web server can direct a web browser to save and
then pass back to the web server under certain circumstances.&nbsp;&nbsp; Some users
configure their web browsers to reject cookies, thus you are advised against building a
site that depends on cookies to work.</p>

<p>Each cookie has these components: 

<ol>
  <li><strong>name</strong> - a string.&nbsp;&nbsp; Since you can get multiple cookies sent to
    you by a web browser, using a unique name will allow you to distinguish the values.</li>
  <li><strong>value</strong> - a string</li>
  <li><strong>path</strong> - a string which must be the prefix of the request from the web
    browser for this cookie to be sent.&nbsp; The string &quot;/&quot; is the prefix of all
    requests.</li>
  <li><strong>domain </strong>- a string which must be the suffix of the name of the machine
    where the request is being sent in order for this cookie to be sent.</li>
  <li><strong>expiration</strong> - a time when this cookie expires. </li>
  <li><strong>secure</strong> - either true or false.&nbsp; If true then this cookie will only
    be sent if the connection is through a secure socket</li>
</ol>

<p>&nbsp;</p>

<p><strong><font face="Courier New">(set-cookie-header request &amp;key name value expires
domain path secure)</font></strong></p>

<p>This function should be called between the calls to <strong>with-http-response </strong>and
<strong>with-http-body</strong>.&nbsp;&nbsp; It can be called more than once.&nbsp; Each
call will cause one Set-Cookie directive to be sent to the web browser. &nbsp;&nbsp;&nbsp;
The <strong>name</strong> and <strong>value</strong> arguments should be given (and they
should be strings).&nbsp; They will be automatically encoded using the same encoding used
in urls (we call it <em>uriencoding). </em>The purpose of this encoding is to convert
characters that are either unprintable or those that have a special meaning into a
printable string.&nbsp;&nbsp;&nbsp; The web browser doesn't care about the <strong>name</strong>
and <strong>value</strong>, it just stores them and sends them back to the web server.
&nbsp;&nbsp;&nbsp; If you use the <strong>get-cookie-values </strong>function to retrieve
the cookie <strong>name</strong> and <strong>value</strong> pairs, then it will
automatically decode the uriencoding.<br>
If the <strong>path </strong>argument isn't given, it will default to &quot;/&quot; which
will allow this cookie to match all requests.<br>
If the <strong>domain</strong> argument isn't given then it will default to the host to
which this request was sent.&nbsp; If you wish you to specify this you are only allowed to
specify a subsequence of the host to which this request was sent (i.e the name of the
machine running the webserver).&nbsp;&nbsp; The <strong>domain</strong> should have at
least two periods in it (i.e.&nbsp; &quot;.foo.com&quot;).<br>
<strong>expiration</strong> can be a lisp universal time or it can be the symbol <strong>:never</strong>
meaning this should never expire.&nbsp; If <strong>expiration </strong>isn't given or is <strong>nil</strong>
then this cookie will expire when the user quits their web browser.<br>
<strong>secure</strong> should be true or false.&nbsp; Any non-nil value is interpreted as
true. The default value is false.</p>

<p>&nbsp;</p>

<p><strong><font face="Courier New">(get-cookie-values request)</font></strong></p>

<p>Return the cookie <strong>name</strong> and <strong>value</strong> pairs from the
header of the request.&nbsp;&nbsp; Each <strong>name</strong> <strong>value</strong> pair
will be in a cons whose <strong>car</strong> is the <strong>name</strong> and whose <strong>cdr</strong>
is the <strong>value</strong>.&nbsp;&nbsp; The names and values will be decoded (in other
words the decoding done by <strong>set-cookie-header</strong> will be undone).</p>

<p>&nbsp;</p>

<hr>

<p>&nbsp;</p>
</body>
</html>
