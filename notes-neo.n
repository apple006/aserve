todo list:

done -- 1. get complete set of mime types by one-time 
	   parsing of /etc/mime.types

2. support cookies

3. make authorization easier to use

4. good logging 
     correct format
     include ip addresse

5. server side includes



-----------------


publishing urls

 support the publishing of files, computing the mime type based
on the extensions (with overriding possible too).

 support computed urls where an action of lisp causes the form
to be printed


html generation:
 want it to be less verbose than cl-http. 

 (html :p (:table (:row (:b "foo") (:b "zip"))
                    (:row (:b "bar") (:i "baz"))))

form:

    :xxx        just do <xxx>
    (:xxx blah) do <xxx>blah</xxx>
    ((:xxx :width 30 :height :40) blah)
		do <xxx with args>blah</xxx>   but don't do the </xxx>
		    if it doesn't make sense.

		  
:p      <p>
:i      <i>
:b      <b>
:table  <table>
:img    <img>

;; pseudo ops
(:stream stream)  - binds variable to do output to this stream


they have corresponding standalone macros to which the abbreviated
form is converted.

the macro name is   with-html-xxx and has the form 
    (with-html-xxx (args) . body)


   (with-html-xxx :set)  just does <xxx> but doesn't do </xxx>
        this is equiv in the html form to :xxx  or ((:xxx :set))
    
   (with-html-xxx :unset) just does </xxx>
        this is equiv in the html form to ((:xxx :unset))




== html generation in Neo (Neo is the internal name for the new franz
   web server)

 Html generation code is invoked when a response must be made to
a request from a www client.    

 Html generation in Neo differs from that in cl-http in these important
ways:

  1. Neo uses the same names as html rather than inventing new more
     verbose and abstract names.   Thus it is easy to predict the
     Neo name for a html generation macro based on the html that it is to
     generate.  This makes any book on html itself a good
     reference book on Neo.

     For example cl-http has 
	 with-table, with-table-row, and with-paragraph 
     whereas neo has
         with-html-table, with-html-tr, and with-html-p

  2. Neo supports a very terse form of html generation as well
     as the with-html-xxx macros.   This is the html macro.


- The html macro

    The html macro is one way of generating html and printing it to
the *response-stream* (which will make its way back to the www client).

    The html macro is given a sequence of arguments.  The arguments
can be 
    1. strings (which are written to *response-stream*)
    2. indicators of html to generate
    3. lisp forms to evaluate and print
    4. lisp forms to evaluate.

for example

    (html "foo" :p "bar")

emits the html:   "foo<p>bar"

An html indictor can be either

    1. a keyword naming an html form, as in the above example.

    2. a list beginning with a keyword naming an html form, 
    
        (:i "foobar")

       which generates "<i>foobar</i>"

    3. a list beginning with a list beginning with an html keyword.
       This is used to specify arguments to the html form

        ((:font :color 'red) "Santa Claus")

       generates  "<font color="red">Santa Claus"</font>"



 Most html forms have an inverse whose name begins with  '/'.  
The forms above make it easy to add the inverse automatically.
There are time when you don't want to add the inverse and that is
done by using formn (1) above, or in forms (2) and (3) not specifying
anything after the first item in the list.  That is 
	 
    (html "foo" :i "bar")

will put "bar" in italics and leave the html generation in italics mode.
Likewise this will do the same thing:

    (html "foo" (:i) "bar")

Also
    (html "foo" ((:font :color 'red)) "bar")

will set the color to red and not unset it.


 It's possible to specify that lisp expressions should be evaluated
and printed to the html stream in one of four ways:
    (:prin1 form1 ... formn)  - use ~s format
    (:princ form1 ... formn)  - use ~a format
    (:prin1-safe form1 ... formn) - use ~s and translate special html chars
    (:princ-safe form1 ... formn) - use ~a and translate special html chars

 the safe versions look for certain special characters (like '<') and
translate them into something (such as "$lt;") which will cause the
correct character to be displayed on the web browser (and not be
iterpreted as an html command. 


 Any other argument to the html macro is just evaluted.  This evaluation
may result in calling the html macro again, or it may just
have a side effect.

 
A simple html document will be generated by this:

(html (:html
	(:head (:title "My Document"))
        (:body (:h1 "My Document")
               "Hello Neo, the time is "
               (:prin1 (get-universal-time))
            
               (incf *my-counter*) ; track invocations of this
)))


-- The html specific macros

  The html macro generates calls to the with-html-xxx macros.  You can
call them yourself.  For each form in html there is a with-html-xxx
macro (where xxx is replaced by the html form name).

  The general form of the macros are

    (with-html-xxx args &rest body)

and this emits an 
    <xxx attrib=value ...> 
where the attrib and values are the 'args'.

Then the body is evaluted (and it likely will emit html too).
Then a </xxx> is emitted (if there is a non-null body and if there
is a </xxx> defined in the html spec.

Two special cases for when you want to control the scope of an html
form:
    (with-html-xxx :set)   generates "<xxx>"
    (with-html-xxx :unset)  generates "</xxx>"


    

==========================

the web server loop   [updated below]

connection is detected

First line is read and the protocol determined. 
We support http protocols 0.9, 1.0 and 1.1

The result is an object of class http-request-0.9, http-request-1.0
or http-request-1.1

This object contains the header information as well as the entity
body (if there is one).
The header information is broken down by header, but it isn't parsed
at all, the values are just strings.   This is done since parsing
the headers can take a while and we don't want to do it unless
we have to.

If the request is badly formed then we respond immediately with a failure
message and that's as far as the request goes.


Next we must determine the entity that is being accessed.



there are four common commands we'll have to deal with

1. :get  - retrieve an entity.
           may be conditional (if-modified-since) so we have to deal with that

2. :head - like get execept we don't send the entity-- just the header.

3. :get with args  ... commonly used after entering data and clicking on
	   a form.  the url is http://..../../..?a=b&c=d
    where the items after the question mark are removed from the url
    and parsed and passed to handler for this url

4. :post  ... used in forms where there is too much data coming
   back to put in the url after a question mark.

   the data appears in the entity body using url encoding.


general flow:
    we need two modes: testing and production:
        In testing mode we only have one process accepting connections
        and doing the work.  This makes for easier debugging.

        In production mode we have a bunch of lisp threads with no
        run reasons.  They are the worker threads.
        When accept connection returns with a stream that stream is
        made the run reason for once of the threads so it will wake up
        and handle the command from that stream.
        If the connection is a keepalive connection then that thread will
        continue to handle that connection until it closes off or 
        fails to give a new request for N seconds.

	   

==================
webserver loop  6/14/99


connection with web server


We read the command (first line) and the headers and stop the
reading at the point the entity data (if any) would occur.
The header may remain unparsed at this point.
If the protocol is 0.9 then there are no headers.

We look for a handler for this command and this url.

If no handler then we send back an error message and close the socket.

If a handler exists then it is called.

The handler is responsible for retrieving the entity data and 
generating a response to the stream.

The handler should generate the header first and then the data
and it should signify when the header is done so that if we
were just given a head command it could break off sending data
back once the header was sent.


-- handlers
    we want to make the typical process work as efficiently as
    possible and with the fewest switches to set... yet make
    it possible to extend and change the behavior too.

    thus we'll have diffenet macros to support the various http commands
    

 standard file publishing
     - only supports :get and :head commands  and verifies that no
       illegal command is given
     - can do preloading of the file for fast response  
     - can do caching of the file (with some timeout to release it)
     - can auto-determine the mime type
     - handles head requests automatically
     - handles if-modified requests automatically
     - handles range requests automatically
    



with-http-response2 ((req ent 
			   &key (check-modified t)
                                (timeout 60)
				) 
                      &rest body)
    
   req is the request object.
   ent is the entity object describing the object we are
   returning.

   Surrounds code to respond to an http request
   if :check-modified it true then if this is a conditional
   get and if it should be short circuited based on the information
   in ent then do that right now without running the body.

   timeout sets the max amount of time we will take to respond
   to this request.  If it takes too long we will simply close
   off the connection.

   This also sets header value that it can based on the
   info in ent.

   The code inside the body should set all the header values
   and then invoke with-http-body


with-http-body ((req ent) &rest body)

    The headers for the response are sent out.

    If this is a head request then nothing else is sent
    else the body is run and it is responsible for sending out
    the entity body.


    

----------- notes 7/6/99

further discussion of the web server loop

[assumed done]: compute the entity object that is the target of the 
                 http command.

[with-http-response2]
1. call function to determine if we'll keep the connection alive
   assuming that was requested

2. check to see if there is an 'if' check in the request header
   and if the entity is up to date based on that check.  If so 
   shortcut things and put put a not modified response

3. start a timer to control the creation of a response to this 
   request.
[end with-http-response2]


[with-http-body]

4. compute-response-headers 
    sets the transfer encoding to 'chunked' if that's appropriate

5. send response-headers
     writes out all response headers.
     If the http request was a 'head' then throw out right now to
     complete the response.

6. compute-response-stream
    put into a slot in the request object a stream appropriate for
    writing to that the user code can use to write the body of the
    response to this request.  
    possibilities;
     we're doing chunking
        we can use the socket stream itself to write to.

     no chunking but keep alive is true
        we can create a string output stream object to capture
        the data and then compute its length and put out a content
        length (hmm... are the headers already written by now??).
        problem: there are only text stream output streams.

     no chunking and no keep alive
        we can write to the socket and then close it after we're done.
        
7. finish-response-stream

[end with-http-body]


--7/8/99
    we have to combine send-response-headers and compute-response
stream since there are cases where we can't sent the headers until
the body has been written to a string-output-stream.


strategies:
    
    :use-socket-stream - just write directly to the bivalent socket stream
    :string-output-stream - create string output stream for the response
            (assert if command is 'get' then :use-socket-stream will be true)

    :chunked          - do chunked output
    <not present>     - don't chunk

    :keep-alive  - turn on keep alive 
    <not present>    - close connection after response

    :post-headers - send headers after body is computed
    <not present>  - send headers before the body 

    :omit-body    - asking for a head, so don't send body
    <not present> - send body



============== examples of how web browser and clients talk to each other ==

+++++++++++++ 1     Netscape talking to Apache

The request is given as a http/1.0 request.  The cookie is present due
to a fluke - the last time we used this redirect program 'localhost'
pointed to the cnn page.
Note how the host part of the url has been put in the host: header line.
Netscape requests that the connection be kept alive.  This is beyond
the http/1.0 spec but is a commonly accepted extension.
There is no body to a GET request so there is no need for a Content-Length
header.

-------- start req1:
GET / HTTP/1.0
Connection: Keep-Alive
User-Agent: Mozilla/4.07 [en] (WinNT; U)
Host: localhost
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
Cookie: CNNid=cf194729-11992-921284246-1

-------------- end req1


The response from Apache is that it is running the http/1.1 protocol. 
I'm sort of surprised that it would respond in this way since you would
think that apache, knowing it was talking to a http/1.0 client, it would
respond with http/1.0 and scale back what it did so that it was understood
by a http/1.0 client.  But it doesn't and I guess that's the correct
thing to do (but the spec is silent).  Note that Apache decided to close
the connection after this response (and it indicates it with the 
Connection header line.)   Is this part of the extended http/1.0+ protcol
or is it http/1.1??  By stating that it will close the connection it 
need not add a Content-Length header line.

------------ start resp1:
HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 18:16:15 GMT
Server: Apache/1.3.0 (Unix)
Connection: close
Content-Type: text/html

<HTML>
	<HEAD>
		<TITLE>Franz Inc:Home Page</TITLE>
		<BASE FONTFACE="helvetica, arial" FONTSIZE="1">
.. much missing here ..
			</TR>
		</TABLE>
	</BODY>
</NOFRAMES>
</HTML>
---------------- end resp1




+++++++++++++++ 2   ie 4.0 talking to apache  (a http/1.1 connection)


IE sends an http/1.1 request and requests that the connection stay
alive.  ie indentifies itself as its equivalent Netscape version.

------ start req1
GET / HTTP/1.1
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT)
Host: localhost
Connection: Keep-Alive

GET /nav/list.html HTTP/1.1
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*
Referer: http://localhost/
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT)
Host: localhost
Connection: Keep-Alive

GET /nav/main.html HTTP/1.1
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*
Referer: http://localhost/
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT)
Host: localhost
Connection: Keep-Alive

------- end req1



Now we see apache's responses.  Since it's talking to 1.1 client
it knows that it can us the chunked transfer coding and it starts
using that.   It also knows that it can set keep-alive parameters
to ensure that the client eventually drops the connections.
In the final response of this set you can see an entity tag, used
to help the caching.

---------- start resp1

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:48 GMT
Server: Apache/1.3.0 (Unix)
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

c3f
<HTML>
	<HEAD>
		<TITLE>Franz Inc:Home Page</TITLE>
		<BASE FONTFACE="helvetica, arial" FONTSIZE="1">
.. much stuff here ....
			</TR>
		</TABLE>
	</BODY>
</NOFRAMES>
</HTML>




0

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:50 GMT
Server: Apache/1.3.0 (Unix)
Keep-Alive: timeout=15, max=99
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

e8a
<HTML>
	<HEAD>
		<TITLE>Franz Inc</TITLE>
		<META NAME="ROBOTS" CONTENT="NOINDEX">	   
... much stuff here ...
<FONT COLOR="#FFFFFF" SIZE=-1>&copy; 1998 Franz Inc.</FONT> 
			</TD>
		</TR>
	</TABLE>
	</BODY>
</HTML>

0

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:50 GMT
Server: Apache/1.3.0 (Unix)
Keep-Alive: timeout=15, max=98
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

e66
<HTML>
	<HEAD>
... much stuff here
		<TITLE>Franz Inc:Home Page</TITLE>

	</BODY>
</HTML>





0

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:52 GMT
Server: Apache/1.3.0 (Unix)
Last-Modified: Mon, 14 Jul 1997 16:18:05 GMT
ETag: "2b21d-4d4-33ca513d"
Accept-Ranges: bytes
Content-Length: 1236
Keep-Alive: timeout=15, max=97
Connection: Keep-Alive
Content-Type: image/gif

.... more stuff...
---------------------- end resp1


