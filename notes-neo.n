publishing urls

 support the publishing of files, computing the mime type based
on the extensions (with overriding possible too).

 support computed urls where an action of lisp causes the form
to be printed


html generation:
 want it to be less verbose than cl-http. 

 (html :p (:table (:row (:b "foo") (:b "zip"))
                    (:row (:b "bar") (:i "baz"))))

form:

    :xxx        just do <xxx>
    (:xxx blah) do <xxx>blah</xxx>
    ((:xxx :width 30 :height :40) blah)
		do <xxx with args>blah</xxx>   but don't do the </xxx>
		    if it doesn't make sense.

		  
:p      <p>
:i      <i>
:b      <b>
:table  <table>
:img    <img>

;; pseudo ops
(:stream stream)  - binds variable to do output to this stream


they have corresponding standalone macros to which the abbreviated
form is converted.

the macro name is   with-html-xxx and has the form 
    (with-html-xxx (args) . body)


   (with-html-xxx :set)  just does <xxx> but doesn't do </xxx>
        this is equiv in the html form to :xxx  or ((:xxx :set))
    
   (with-html-xxx :unset) just does </xxx>
        this is equiv in the html form to ((:xxx :unset))




== html generation in Neo (Neo is the internal name for the new franz
   web server)

 Html generation code is invoked when a response must be made to
a request from a www client.    

 Html generation in Neo differs from that in cl-http in these important
ways:

  1. Neo uses the same names as html rather than inventing new more
     verbose and abstract names.   Thus it is easy to predict the
     Neo name for a html generation macro based on the html that it is to
     generate.  This makes any book on html itself a good
     reference book on Neo.

     For example cl-http has 
	 with-table, with-table-row, and with-paragraph 
     whereas neo has
         with-html-table, with-html-tr, and with-html-p

  2. Neo supports a very terse form of html generation as well
     as the with-html-xxx macros.   This is the html macro.


- The html macro

    The html macro is one way of generating html and printing it to
the *response-stream* (which will make its way back to the www client).

    The html macro is given a sequence of arguments.  The arguments
can be 
    1. strings (which are written to *response-stream*)
    2. indicators of html to generate
    3. lisp forms to evaluate and print
    4. lisp forms to evaluate.

for example

    (html "foo" :p "bar")

emits the html:   "foo<p>bar"

An html indictor can be either

    1. a keyword naming an html form, as in the above example.

    2. a list beginning with a keyword naming an html form, 
    
        (:i "foobar")

       which generates "<i>foobar</i>"

    3. a list beginning with a list beginning with an html keyword.
       This is used to specify arguments to the html form

        ((:font :color 'red) "Santa Claus")

       generates  "<font color="red">Santa Claus"</font>"



 Most html forms have an inverse whose name begins with  '/'.  
The forms above make it easy to add the inverse automatically.
There are time when you don't want to add the inverse and that is
done by using formn (1) above, or in forms (2) and (3) not specifying
anything after the first item in the list.  That is 
	 
    (html "foo" :i "bar")

will put "bar" in italics and leave the html generation in italics mode.
Likewise this will do the same thing:

    (html "foo" (:i) "bar")

Also
    (html "foo" ((:font :color 'red)) "bar")

will set the color to red and not unset it.


 It's possible to specify that lisp expressions should be evaluated
and printed to the html stream in one of four ways:
    (:prin1 form1 ... formn)  - use ~s format
    (:princ form1 ... formn)  - use ~a format
    (:prin1-safe form1 ... formn) - use ~s and translate special html chars
    (:princ-safe form1 ... formn) - use ~a and translate special html chars

 the safe versions look for certain special characters (like '<') and
translate them into something (such as "$lt;") which will cause the
correct character to be displayed on the web browser (and not be
iterpreted as an html command. 


 Any other argument to the html macro is just evaluted.  This evaluation
may result in calling the html macro again, or it may just
have a side effect.

 
A simple html document will be generated by this:

(html (:html
	(:head (:title "My Document"))
        (:body (:h1 "My Document")
               "Hello Neo, the time is "
               (:prin1 (get-universal-time))
            
               (incf *my-counter*) ; track invocations of this
)))


-- The html specific macros

  The html macro generates calls to the with-html-xxx macros.  You can
call them yourself.  For each form in html there is a with-html-xxx
macro (where xxx is replaced by the html form name).

  The general form of the macros are

    (with-html-xxx args &rest body)

and this emits an 
    <xxx attrib=value ...> 
where the attrib and values are the 'args'.

Then the body is evaluted (and it likely will emit html too).
Then a </xxx> is emitted (if there is a non-null body and if there
is a </xxx> defined in the html spec.

Two special cases for when you want to control the scope of an html
form:
    (with-html-xxx :set)   generates "<xxx>"
    (with-html-xxx :unset)  generates "</xxx>"


    

==========================

the web server loop

connection is detected

First line is read and the protocol determined. 
We support http protocols 0.9, 1.0 and 1.1

The result is an object of class http-request-0.9, http-request-1.0
or http-request-1.1

This object contains the header information as well as the entity
body (if there is one).
The header information is broken down by header, but it isn't parsed
at all, the values are just strings.   This is done since parsing
the headers can take a while and we don't want to do it unless
we have to.

If the request is badly formed then we respond immediately with a failure
message and that's as far as the request goes.


Next we must determine the entity that is being accessed.



there are four common commands we'll have to deal wtih

1. :get  - retrieve an entity.
           may be conditional (if-modified-since) so we have to deal with that

2. :head - like get execept we don't send the entity-- just the header.

3. :get with args  ... commonly used after entering data and clicking on
	   a form.  the url is http://..../../..?a=b&c=d
    where the items after the question mark are removed from the url
    and parsed and passed to handler for this url

4. :post  ... used in forms where there is too much data coming
   back to put in the url after a question mark.


	   










============== examples of how web browser and clients talk to each other ==

+++++++++++++ 1     Netscape talking to Apache

The request is given as a http/1.0 request.  The cookie is present due
to a fluke - the last time we used this redirect program 'localhost'
pointed to the cnn page.
Note how the host part of the url has been put in the host: header line.
Netscape requests that the connection be kept alive.  This is beyond
the http/1.0 spec but is a commonly accepted extension.
There is no body to a GET request so there is no need for a Content-Length
header.

-------- start req1:
GET / HTTP/1.0
Connection: Keep-Alive
User-Agent: Mozilla/4.07 [en] (WinNT; U)
Host: localhost
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
Cookie: CNNid=cf194729-11992-921284246-1

-------------- end req1


The response from Apache is that it is running the http/1.1 protocol. 
I'm sort of surprised that it would respond in this way since you would
think that apache, knowing it was talking to a http/1.0 client, it would
respond with http/1.0 and scale back what it did so that it was understood
by a http/1.0 client.  But it doesn't and I guess that's the correct
thing to do (but the spec is silent).  Note that Apache decided to close
the connection after this response (and it indicates it with the 
Connection header line.)   Is this part of the extended http/1.0+ protcol
or is it http/1.1??  By stating that it will close the connection it 
need not add a Content-Length header line.

------------ start resp1:
HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 18:16:15 GMT
Server: Apache/1.3.0 (Unix)
Connection: close
Content-Type: text/html

<HTML>
	<HEAD>
		<TITLE>Franz Inc:Home Page</TITLE>
		<BASE FONTFACE="helvetica, arial" FONTSIZE="1">
.. much missing here ..
			</TR>
		</TABLE>
	</BODY>
</NOFRAMES>
</HTML>
---------------- end resp1




+++++++++++++++ 2   ie 4.0 talking to apache  (a http/1.1 connection)


IE sends an http/1.1 request and requests that the connection stay
alive.  ie indentifies itself as its equivalent Netscape version.

------ start req1
GET / HTTP/1.1
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT)
Host: localhost
Connection: Keep-Alive

GET /nav/list.html HTTP/1.1
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*
Referer: http://localhost/
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT)
Host: localhost
Connection: Keep-Alive

GET /nav/main.html HTTP/1.1
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*
Referer: http://localhost/
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows NT)
Host: localhost
Connection: Keep-Alive

------- end req1



Now we see apache's responses.  Since it's talking to 1.1 client
it knows that it can us the chunked transfer coding and it starts
using that.   It also knows that it can set keep-alive parameters
to ensure that the client eventually drops the connections.
In the final response of this set you can see an entity tag, used
to help the caching.

---------- start resp1

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:48 GMT
Server: Apache/1.3.0 (Unix)
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

c3f
<HTML>
	<HEAD>
		<TITLE>Franz Inc:Home Page</TITLE>
		<BASE FONTFACE="helvetica, arial" FONTSIZE="1">
.. much stuff here ....
			</TR>
		</TABLE>
	</BODY>
</NOFRAMES>
</HTML>




0

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:50 GMT
Server: Apache/1.3.0 (Unix)
Keep-Alive: timeout=15, max=99
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

e8a
<HTML>
	<HEAD>
		<TITLE>Franz Inc</TITLE>
		<META NAME="ROBOTS" CONTENT="NOINDEX">	   
... much stuff here ...
<FONT COLOR="#FFFFFF" SIZE=-1>&copy; 1998 Franz Inc.</FONT> 
			</TD>
		</TR>
	</TABLE>
	</BODY>
</HTML>

0

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:50 GMT
Server: Apache/1.3.0 (Unix)
Keep-Alive: timeout=15, max=98
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

e66
<HTML>
	<HEAD>
... much stuff here
		<TITLE>Franz Inc:Home Page</TITLE>

	</BODY>
</HTML>





0

HTTP/1.1 200 OK
Date: Tue, 13 Apr 1999 21:36:52 GMT
Server: Apache/1.3.0 (Unix)
Last-Modified: Mon, 14 Jul 1997 16:18:05 GMT
ETag: "2b21d-4d4-33ca513d"
Accept-Ranges: bytes
Content-Length: 1236
Keep-Alive: timeout=15, max=97
Connection: Keep-Alive
Content-Type: image/gif

.... more stuff...
---------------------- end resp1


